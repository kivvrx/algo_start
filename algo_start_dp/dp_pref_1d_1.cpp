// 1 2 3 4 5 6 7
// 1 2 3 4 5 6 7 8
// 1 в массиве храним количество способов добраться до i точки
// 2 база первый и второй элементы равны 1 второй элемент понятно почему а первый 
// потому что иначе невозможно решить задачу 
// 3 функция перехода dp[i] = dp[i-1] + dp[i-2] в них все предыдущие способы уже есть
// 4 ответ это последний элемент массива 
// 5 идем слева направо
#include <iostream>
#include <vector>

int main() {
    int n;
    std::cin >> n;
    const int K = static_cast<int>(1e6) + 7;
    std::vector<int> dp(n + 1, 0);
    dp[1] = 1;
    if (n >= 2) dp[2] = 1;
    for (int i = 3; i <= n; ++i) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % K;
    }
    std::cout << dp[n] << '\n';
    return 0;
}

