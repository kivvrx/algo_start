// 1 в каждой клетке dp[i][j] хранится размер наибольшего квадратного 
// участка газона который заканчивается в клетке(i j)
// 2 база для первой строки и первого столбца 
// если клетка O то dp[i][j] = 1 (можно образовать квадрат 1*1)
// если клетка X то dp[i][j] = 0
// 3 переход размер квадрата здесь зависит от того какой минимальный квадрат 
// можно протянуть сверху слева и по диагонали
// если клетка X, то dp[i][j] = 0
// 4 идём слева направо и сверху вниз
// 5 ответ максимальное значение среди всех dp[i][j]
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    vector<vector<char>> grid(N, vector<char>(M));
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            cin >> grid[i][j];
    vector<vector<int>> dp(N, vector<int>(M, 0));
    int maxpl = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (grid[i][j] == 'O') {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1; // на границе только 1*1
                }
                // тут важно понимать что элементы слева справа и по диагонали в dp это
                // можно представить как как бы правые нижние элементы 
                // квадратов если там число отличное от нуля
                else {
                    dp[i][j] = 1 + min(dp[i - 1][j],
                        min(dp[i][j - 1], dp[i - 1][j - 1]));
                }
                maxpl = max(maxpl, dp[i][j]);
            }
        }
    }
    cout << maxpl;
    return 0;
}

