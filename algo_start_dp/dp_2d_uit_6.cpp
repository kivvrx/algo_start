// пусть идем от 11 к 34
// разницы по строка |3-1| (необязательно так может быть наоборот поэтому модуль)
// = 2 
// по столбцам |4-1| = 3 
// итог 3 + 2 
// у нас еще есть K если оно меньше dist по этой формуле ответа нет
// а если больше больше нужно чтобы остаток от k-dist был четным
// чтобы потратить лишние шаги и всё равно оказаться в нужной точке
// нужно делать пары обратных шагов 
// **********************************************
// если мы начнём прямо в этот же массив записывать новые значения для следующего 
// шага то
// часть клеток уже будет обновлена
// часть клеток ещё хранит старые значения
// и мы начнём использовать смешанные данные где то старые где то новые
#include <vector>
#include <iostream>
using namespace std;
const int MOD = 1000007;

int main() {
    int N, M;
    cin >> N >> M;
    int A, B, C, D, K;
    cin >> A >> B >> C >> D >> K;

    int dist = abs(A - C) + abs(B - D);
    if (dist > K || (K - dist) % 2 != 0) {
        cout << 0;
        return 0;
    }
    vector<vector<int>> cur(N + 1, vector<int>(M + 1, 0));
    cur[A][B] = 1;

    int dx[4] = { 1, -1, 0, 0 };
    int dy[4] = { 0, 0, 1, -1 };

    for (int step = 0; step < K; step++) {
        vector<vector<int>> nxt(N + 1, vector<int>(M + 1, 0));
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= M; j++) {
                if (cur[i][j] == 0) continue;
                for (int d = 0; d < 4; d++) {
                    int ni = i + dx[d], nj = j + dy[d];
                    // а если не соблюдается значит вне поля поэтому они никогда не учитываются
                    if (ni >= 1 && ni <= N && nj >= 1 && nj <= M) {
                        // например при step = 0 мы посмотрим только на лево право верх и низ
                        // от начальной клетки мы не заполняем сразу dp чтобы не
                        // мешать значения так проход идет с лева направо сверху вниз 
                        // и там будет перемешивание поэтому промежуточный массив необ
                        // ходим 
                        nxt[ni][nj] = (nxt[ni][nj] + cur[i][j]) % MOD;
                        // почему прибавляем ? 
                        // потому что мы сейчас рассматриваем сколько вариантов 
                        // прийти в клетку при увеличении шага 
                        // мы можем туда прийти от соседней значит 
                        // мы уже прошли например 2 шага а теперь у нас есть еще 3 шаг
                        // и число вариантов 2 шагов мы прибавляем к 3 так как у нас остался один шаг
                    }
                }
            }
        }
        cur.swap(nxt);
    }
    cout << cur[C][D];
    return 0;
}
// тут нужны примеры чтобы понять логику 
// покажим состояния 
// cur(старый слой шаг 0) :
//    0 0 0
//    0 1 0
//    0 0 0
//
//    nxt(новый слой, шаг 1)
//    0 1 0
//    1 0 1
//    0 1 0
// делаем swap 
// cur(текущий слой шаг 1)
//    0 1 0
//    1 0 1
//    0 1 0
//
//    nxt(обнулится на следующей итерации)
//    0 0 0
//    0 1 0
//    0 0 0
//  ***************
// cur (шаг 1)
//0 1 0
//1 0 1
//0 1 0
//nxt(шаг 2 до swap)
//    2 0 2
//    0 4 0
//    2 0 2
// swap
//cur(шаг 2) 
//    2 0 2
//    0 4 0
//    2 0 2
//
//    nxt(старый слой будет обнулён) 
//    0 1 0
//    1 0 1
//    0 1 0
