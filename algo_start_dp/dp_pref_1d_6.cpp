// 1 в dp храним количество способов попасть в i метр
// 2 база dp[1] = 1 по условию иначе алгоритм не запустится
// 3 dp[i] = dp[i-1] + dp[i-k] ... 
// 4 идем слева направо 
// 5 ответ послежний элемент массива
#include <iostream>
#include <vector>

int main() {
    int n, k;
    std::cin >> n >> k;
    const int K = 1000007;
    std::vector<int> dp(n + 1, 0);
    dp[1] = 1;
    int w_s = dp[1];

    for (int i = 2; i <= n; ++i) {
        dp[i] = w_s; // сумма всех способов попасть на i тоесть сумма 
        // всех предыдущих dp
        w_s = (w_s + dp[i]) % K; // теперь окно в dp сдвинули
        // на 1 вправо если i - k >= 1 или просто расширили если меньше
        // если расширили то ничего делать не нужно а если сдвинули то лишний 
        // левый элемент нужно удалить из окна 
        // старое окно dp[i - 1] + dp[i - 2] + ... + dp[i - K]
        // новое окно dp[i] + dp[i - 1] + ... + dp[i - K + 1] + dp[i-K] вот это + 1 
        // это отнимание от суммы окна 
        if (i - k >= 1) {
            // любое число и это же число плюс K дают одинаковый остаток при делении 
            // на K: (x+K)%K = x%K
            // мы это делаем чтобы число суммы окна было точно положительным
            // если dp[i-k] > w_s текущего
            w_s = (w_s - dp[i - k] + K) % K; // убираем лишний
        }
    }

    std::cout << dp[n] << '\n';
    return 0;
}

